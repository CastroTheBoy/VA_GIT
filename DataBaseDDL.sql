DROP TABLE IF EXISTS PLAYER CASCADE;
CREATE TABLE PLAYER (
	Player_Id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	Username VARCHAR(255) NOT NULL UNIQUE,
	Seed_Token INTEGER NOT NULL,
	Account_Creation_Date DATE NOT NULL
);

COMMENT ON TABLE PLAYER IS 'Main Player table, holds critical data required for fast access.';
COMMENT ON COLUMN PLAYER.Player_Id IS 'Automatically generated player identificator used for identification within the database.';
COMMENT ON COLUMN PLAYER.Username IS 'The in-game username for a player.';
COMMENT ON COLUMN PLAYER.Seed_Token IS 'A random integer generated by game client for modification of various in-game functions.';
COMMENT ON COLUMN PLAYER.Account_Creation_Date IS 'Date when player created their account.';

DROP TABLE IF EXISTS PLAYER_SESSION CASCADE;
CREATE TABLE PLAYER_SESSION (
	Player_Id INTEGER REFERENCES PLAYER(Player_Id) UNIQUE NOT NULL,
	Session_Id INTEGER PRIMARY KEY,
	Login_Timestamp TIMESTAMP(0) NOT NULL,
	Session_Length TIME NOT NULL,
	Mob_Kill_Count INTEGER NOT NULL,
	Death_Count INTEGER NOT NULL,
	Experience_Gained INTEGER NOT NULL
);

CREATE OR REPLACE FUNCTION PlayerSessionCheckForDecrement() RETURNS TRIGGER
AS $$
BEGIN
	IF
		OLD.Mob_Kill_Count > NEW.Mob_Kill_Count
		OR OLD.Death_Count > NEW.Death_Count
		OR OLD.Experience_Gained > NEW.Experience_Gained
	THEN RAISE EXCEPTION 'Invalid player session update! Mob_Kill_Count, Death_Count or Experience_Gained attepmted a decrement.';
	END IF;
	RETURN NEW;
END; $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER PLAYER_SESSION_DECREMENT_CHECK AFTER UPDATE ON PLAYER_SESSION
FOR EACH ROW
EXECUTE FUNCTION PlayerSessionCheckForDecrement();

COMMENT ON TABLE PLAYER_SESSION IS 'Table for live player sessions. Data is queued and updated every five minutes. Data is aggregated accross all characters.';
COMMENT ON COLUMN PLAYER_SESSION.Player_Id IS 'Automatically generated player identificator used for identification within the database | references PLAYER.Player_Id';
COMMENT ON COLUMN PLAYER_SESSION.Session_Id IS 'Player session identificator generated by server.';
COMMENT ON COLUMN PLAYER_SESSION.Login_Timestamp IS 'Time of login.';
COMMENT ON COLUMN PLAYER_SESSION.Session_Length IS 'Current session length.';
COMMENT ON COLUMN PLAYER_SESSION.Mob_Kill_Count IS 'Kill count of enemyEntity type mobs.';
COMMENT ON COLUMN PLAYER_SESSION.Death_Count IS 'Death count, can be accidentally incremented by a client crash.';
COMMENT ON COLUMN PLAYER_SESSION.Experience_Gained IS 'Amount of experience gained by any means.';

DROP TABLE IF EXISTS PLAYER_SESSION_LOG CASCADE;
CREATE TABLE PLAYER_SESSION_LOG (
	Player_Id INTEGER REFERENCES PLAYER(Player_Id) NOT NULL,
	Session_Id INTEGER NOT NULL,
	Login_Timestamp TIMESTAMP(0) NOT NULL,
	Logoff_Timestamp TIMESTAMP(0) NOT NULL,
	Session_Length TIME NOT NULL,
	Mob_Kill_Count INTEGER NOT NULL,
	Death_Count INTEGER NOT NULL,
	Experience_Gained INTEGER NOT NULL,
	PRIMARY KEY (Player_Id, Session_Id, Login_Timestamp)
);

CREATE INDEX IF NOT EXISTS PSL_PLID_IDX ON PLAYER_SESSION_LOG(Player_Id);
CREATE INDEX IF NOT EXISTS PSL_SSID_IDX ON PLAYER_SESSION_LOG(Session_Id);

COMMENT ON TABLE PLAYER_SESSION_LOG IS 'Table for historical player sessions.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Player_Id IS 'Automatically generated player identificator used for identification within the database | references PLAYER.Player_Id';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Session_Id IS 'Player session identificator generated by server.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Login_Timestamp IS 'Time of login.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Logoff_Timestamp IS 'Time of session termination. A client crash can end session.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Session_Length IS 'Session length.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Mob_Kill_Count IS 'Kill count of enemyEntity type mobs.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Death_Count IS 'Death count, can be accidentally incremented by a client crash.';
COMMENT ON COLUMN PLAYER_SESSION_LOG.Experience_Gained IS 'Amount of experience gained by any means.';

CREATE OR REPLACE PROCEDURE LogPlayerSession (sessId INTEGER, LogOffTime TIMESTAMP(0))
LANGUAGE SQL
BEGIN ATOMIC
	INSERT INTO PLAYER_SESSION_LOG
	SELECT
		Player_Id,
		Session_Id,
		Login_Timestamp,
		LogOffTime,
		Session_Length,
		Mob_Kill_Count,
		Death_Count,
		Experience_Gained
	FROM
		PLAYER_SESSION
	WHERE
		Session_Id = sessId;
	DELETE FROM PLAYER_SESSION WHERE Session_Id = sessId;
END;

DROP TABLE IF EXISTS DATA_ATTRIBUTE_TYPE CASCADE;
CREATE TABLE DATA_ATTRIBUTE_TYPE (
	Attribute_Type_Code INTEGER PRIMARY KEY,
	Attribute_Type_Name VARCHAR(255) NOT NULL,
	Attribute_Type_Desc VARCHAR(1024) NOT NULL
);

COMMENT ON TABLE DATA_ATTRIBUTE_TYPE IS 'Definitions for different attribute types.';
COMMENT ON COLUMN DATA_ATTRIBUTE_TYPE.Attribute_Type_Code IS 'Manually maintained identificator for attribute types.';
COMMENT ON COLUMN DATA_ATTRIBUTE_TYPE.Attribute_Type_Name IS 'Attribute name.';
COMMENT ON COLUMN DATA_ATTRIBUTE_TYPE.Attribute_Type_Desc IS 'Attribute description.';

DROP TABLE IF EXISTS DATA_ATTRIBUTE_VALUE CASCADE;
CREATE TABLE DATA_ATTRIBUTE_VALUE (
	Attribute_Type_Code INTEGER REFERENCES DATA_ATTRIBUTE_TYPE(Attribute_Type_Code) NOT NULL,
	Attribute_Value_Code INTEGER NOT NULL,
	Attribute_Value_Name VARCHAR(255) NOT NULL,
	Attribute_Value_Desc VARCHAR(1024) NOT NULL,
	Parent_Attribute_Type_Code INTEGER REFERENCES DATA_ATTRIBUTE_TYPE(Attribute_Type_Code),
	PRIMARY KEY (Attribute_Type_Code, Attribute_Value_Code)
);

CREATE INDEX IF NOT EXISTS DAC_ATC_IDX ON DATA_ATTRIBUTE_VALUE(Attribute_Type_Code);

COMMENT ON TABLE DATA_ATTRIBUTE_VALUE IS 'Definitions for the possible values for each attribute type.';
COMMENT ON COLUMN DATA_ATTRIBUTE_VALUE.Attribute_Type_Code IS 'Manually maintained identificator for attribute types | references DATA_ATTRIBUTE_TYPE.Attribute_Type.';
COMMENT ON COLUMN DATA_ATTRIBUTE_VALUE.Attribute_Value_Code IS 'Identifying code for different attribute values.';
COMMENT ON COLUMN DATA_ATTRIBUTE_VALUE.Attribute_Value_Name IS 'Attribute value name.';
COMMENT ON COLUMN DATA_ATTRIBUTE_VALUE.Attribute_Value_Desc IS 'Attribute value description.';
COMMENT ON COLUMN DATA_ATTRIBUTE_VALUE.Parent_Attribute_Type_Code IS 'Parent Attribute_Type_Code, if one exists.';

DROP TABLE IF EXISTS PLAYER_ATTRIBUTE CASCADE;
CREATE TABLE PLAYER_ATTRIBUTE (
	Player_Id INTEGER REFERENCES PLAYER(Player_Id) NOT NULL,
	Player_Attribute_Code INTEGER NOT NULL,
	Attribute_Value VARCHAR(1024) NOT NULL,
	Attribute_Start_Date DATE NOT NULL,
	Attribute_End_Date DATE,
	PRIMARY KEY (Player_Id, Player_Attribute_Code, Attribute_Start_Date)
);

CREATE OR REPLACE FUNCTION CheckIfPlayerAttributeValueExists() RETURNS TRIGGER
AS $$
BEGIN
	IF NOT EXISTS (SELECT FROM DATA_ATTRIBUTE_VALUE WHERE Attribute_Type_Code = 1 AND Attribute_Value_Code = NEW.Player_Attribute_Code)
	THEN RAISE EXCEPTION 'Attribute_Value_Code = % does not exist for Attribute_Type_Code = 1!', NEW.Player_Attribute_Code;
	END IF;
	RETURN NEW;
END; $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER PLAYER_ATTRIBUTE_VALIDITY_CHECK BEFORE INSERT ON PLAYER_ATTRIBUTE
FOR EACH ROW
EXECUTE FUNCTION CheckIfPlayerAttributeValueExists();

CREATE OR REPLACE FUNCTION CheckAttributeDates() RETURNS TRIGGER
AS $$
BEGIN
	IF NEW.Attribute_Start_Date >= COALESCE(NEW.Attribute_End_Date, DATE '9999-12-31')
	THEN RAISE EXCEPTION 'Attribute_End_Date has to be NULL or greater than Attribute_Start_Date';
	END IF;
	RETURN NEW;
END; $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER PLAYER_ATTRIBUTE_DATE_CHECK BEFORE INSERT ON PLAYER_ATTRIBUTE
FOR EACH ROW
EXECUTE FUNCTION CheckAttributeDates();

CREATE INDEX IF NOT EXISTS PA_PLID_IDX ON PLAYER_ATTRIBUTE(Player_Id);
CREATE INDEX IF NOT EXISTS PA_PLIDPAC_IDX ON PLAYER_ATTRIBUTE(Player_Id, Player_Attribute_Code);

COMMENT ON TABLE PLAYER_ATTRIBUTE IS 'Table containing additional information about players, can change overtime.';
COMMENT ON COLUMN PLAYER_ATTRIBUTE.Player_Id IS 'Automatically generated player identificator used for identification within the database | references PLAYER.Player_Id.';
COMMENT ON COLUMN PLAYER_ATTRIBUTE.Player_Attribute_Code IS 'Code for a player attribute | references DATA_ATTRIBUTE_VALUE.Attribute_Code WHERE Attribute_Type = 1.';
COMMENT ON COLUMN PLAYER_ATTRIBUTE.Attribute_Value IS 'Actual value of attribute.';
COMMENT ON COLUMN PLAYER_ATTRIBUTE.Attribute_Start_Date IS 'Start date of attribute.';
COMMENT ON COLUMN PLAYER_ATTRIBUTE.Attribute_End_Date IS 'End date of attribute.';

DROP TABLE IF EXISTS PLAYER_CHARACTER CASCADE;
CREATE TABLE PLAYER_CHARACTER (
	Player_Id INTEGER REFERENCES PLAYER(Player_Id) NOT NULL,
	Character_Id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	Character_Name VARCHAR(512) NOT NULL UNIQUE,
	Character_Class_Value_Code INTEGER NOT NULL,
	Death_Count INTEGER NOT NULL,
	Experience_Gained INTEGER NOT NULL,
	Raw_Damage INTEGER NOT NULL,
	Quests_Completed INTEGER NOT NULL
);

CREATE OR REPLACE FUNCTION CheckIfCharacterClassValueExists() RETURNS TRIGGER
AS $$
BEGIN
	IF NOT EXISTS (SELECT FROM DATA_ATTRIBUTE_VALUE WHERE Attribute_Type_Code = 2 AND Attribute_Value_Code = NEW.Character_Class_Value_Code)
	THEN RAISE EXCEPTION 'Attribute_Value_Code = % does not exist for Attribute_Type_Code = 2!', NEW.Character_Class_Value_Code;
	END IF;
	RETURN NEW;
END; $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER CHARACTER_CLASS_VALIDITY_CHECK BEFORE INSERT ON PLAYER_CHARACTER
FOR EACH ROW
EXECUTE FUNCTION CheckIfCharacterClassValueExists();

CREATE INDEX IF NOT EXISTS PC_PLID_IDX ON PLAYER_CHARACTER(Player_Id);
CREATE INDEX IF NOT EXISTS PC_PLIDCHID_IDX ON PLAYER_CHARACTER(Player_Id, Character_Id);

COMMENT ON TABLE PLAYER_CHARACTER IS 'Table for player character data.';
COMMENT ON COLUMN PLAYER_CHARACTER.Player_Id IS 'Automatically generated player identificator used for identification within the database | references PLAYER.Player_Id.';
COMMENT ON COLUMN PLAYER_CHARACTER.Character_Id IS 'Automatically generated player character identificator used for identification within the database.';
COMMENT ON COLUMN PLAYER_CHARACTER.Character_Name IS 'Name of a character as displayed in-game.';
COMMENT ON COLUMN PLAYER_CHARACTER.Character_Class_Value_Code IS 'Code for a character class type | references DATA_ATTRIBUTE_VALUE.Attribute_Code WHERE Attribute_Type = 2.';
COMMENT ON COLUMN PLAYER_CHARACTER.Death_Count IS 'Death count, can be accidentally incremented by a client crash.';
COMMENT ON COLUMN PLAYER_CHARACTER.Experience_Gained IS 'Amount of experience gained by any means.';
COMMENT ON COLUMN PLAYER_CHARACTER.Raw_Damage IS 'Characters damage without any additional modifiers. Used as base value when applying buff modifiers.';
COMMENT ON COLUMN PLAYER_CHARACTER.Quests_Completed IS 'Amount of completed quests. Failed, in-progress and global quests don not count towards this metric.';

DROP TABLE IF EXISTS CHARACTER_CLASS_ATTRIBUTE CASCADE;
CREATE TABLE CHARACTER_CLASS_ATTRIBUTE (
	Character_Class_Value_Code INTEGER NOT NULL,
	Class_Attribute_Value_Code INTEGER NOT NULL,
	Attribute_Value VARCHAR(1024) NOT NULL,
	Attribute_Start_Date DATE NOT NULL,
	Attribute_End_Date DATE,
	PRIMARY KEY (Character_Class_Value_Code, Class_Attribute_Value_Code, Attribute_Start_Date)
);

CREATE OR REPLACE TRIGGER CLASS_ATTRIBUTE_DATE_CHECK BEFORE INSERT ON CHARACTER_CLASS_ATTRIBUTE
FOR EACH ROW
EXECUTE FUNCTION CheckAttributeDates();

CREATE OR REPLACE FUNCTION CheckIfClassAttributeValueExists() RETURNS TRIGGER
AS $$
BEGIN
	IF NOT EXISTS (SELECT FROM DATA_ATTRIBUTE_VALUE WHERE Attribute_Type_Code = 3 AND Attribute_Value_Code = NEW.Class_Attribute_Value_Code)
	THEN RAISE EXCEPTION 'Attribute_Value_Code = % does not exist for Attribute_Type_Code = 3!', NEW.Class_Attribute_Value_Code;
	END IF;
	RETURN NEW;
END; $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER CHARACTER_CLASS_VALIDITY_CHECK BEFORE INSERT ON CHARACTER_CLASS_ATTRIBUTE
FOR EACH ROW
EXECUTE FUNCTION CheckIfCharacterClassValueExists();

CREATE OR REPLACE TRIGGER CLASS_ATTRIBUTE_VALIDITY_CHECK BEFORE INSERT ON CHARACTER_CLASS_ATTRIBUTE
FOR EACH ROW
EXECUTE FUNCTION CheckIfClassAttributeValueExists();

COMMENT ON TABLE CHARACTER_CLASS_ATTRIBUTE IS 'Table containing additional information about players, can change overtime.';
COMMENT ON COLUMN CHARACTER_CLASS_ATTRIBUTE.Character_Class_Value_Code IS 'Code for a character class type | references DATA_ATTRIBUTE_VALUE.Attribute_Code WHERE Attribute_Type = 2.';
COMMENT ON COLUMN CHARACTER_CLASS_ATTRIBUTE.Class_Attribute_Value_Code IS 'Code for a class attribute | references DATA_ATTRIBUTE_VALUE.Attribute_Code WHERE Attribute_Type = 3.';
COMMENT ON COLUMN CHARACTER_CLASS_ATTRIBUTE.Attribute_Value IS 'Actual value of attribute.';
COMMENT ON COLUMN CHARACTER_CLASS_ATTRIBUTE.Attribute_Start_Date IS 'Start date of attribute.';
COMMENT ON COLUMN CHARACTER_CLASS_ATTRIBUTE.Attribute_End_Date IS 'End date of attribute.';

DROP TABLE IF EXISTS CHARACTER_INVENTORY CASCADE;
CREATE TABLE CHARACTER_INVENTORY (
	Character_Id INTEGER REFERENCES PLAYER_CHARACTER(Character_Id) NOT NULL,
	Inventory_Slot INTEGER NOT NULL,
	Item_Name VARCHAR(512) NOT NULL,
	Item_Weight DECIMAL(18,2) NOT NULL,
	Item_Description VARCHAR(1024) NOT NULL,
	PRIMARY KEY (Character_Id, Inventory_Slot)
);

CREATE INDEX IF NOT EXISTS CI_CHID_IDX ON CHARACTER_INVENTORY(Character_Id);

COMMENT ON TABLE CHARACTER_INVENTORY IS 'Table containing information about each characters inventory.';
COMMENT ON COLUMN CHARACTER_INVENTORY.Character_Id IS 'Automatically generated player character identificator used for identification within the database | references PLAYER_CHARACTER.Character_Id.';
COMMENT ON COLUMN CHARACTER_INVENTORY.Inventory_Slot IS 'A unique inventory slot for each character, once occupied cannot be used by another item. Actual slot allocation and maximum slot amount is managed on client level.';
COMMENT ON COLUMN CHARACTER_INVENTORY.Item_Name IS 'Item name as displayed in-game.';
COMMENT ON COLUMN CHARACTER_INVENTORY.Item_Weight IS 'Item weight as displayed in-game.';
COMMENT ON COLUMN CHARACTER_INVENTORY.Item_Description IS 'Item description as displayed in-game.';

DO $$
BEGIN
	IF EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname = 'main_read_access') THEN
		DROP OWNED BY MAIN_READ_ACCESS;
		DROP ROLE MAIN_READ_ACCESS;
	END IF;
END; $$;
CREATE ROLE MAIN_READ_ACCESS WITH NOLOGIN;
GRANT USAGE ON SCHEMA PUBLIC TO MAIN_READ_ACCESS;
GRANT SELECT ON 
	PLAYER, 
	PLAYER_SESSION,
	PLAYER_SESSION_LOG,
	DATA_ATTRIBUTE_TYPE,
	DATA_ATTRIBUTE_VALUE,
	PLAYER_ATTRIBUTE,
	PLAYER_CHARACTER,
	CHARACTER_CLASS_ATTRIBUTE,
	CHARACTER_INVENTORY
TO MAIN_READ_ACCESS;

DO $$
BEGIN
	IF EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname = 'main_edit_access') THEN
		DROP OWNED BY MAIN_EDIT_ACCESS;
		DROP ROLE MAIN_EDIT_ACCESS;
	END IF;
END; $$;
CREATE ROLE MAIN_EDIT_ACCESS WITH NOLOGIN;
GRANT USAGE ON SCHEMA PUBLIC TO MAIN_EDIT_ACCESS;
GRANT INSERT, UPDATE, DELETE ON 
	PLAYER, 
	PLAYER_SESSION,
	PLAYER_ATTRIBUTE,
	PLAYER_CHARACTER,
	CHARACTER_CLASS_ATTRIBUTE,
	CHARACTER_INVENTORY
TO MAIN_EDIT_ACCESS;

DO $$
BEGIN
	IF EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname = 'client_reader') THEN
		DROP OWNED BY CLIENT_READER;
		DROP ROLE CLIENT_READER;
	END IF;
END; $$;
CREATE ROLE CLIENT_READER 
	LOGIN
	PASSWORD 'mA1NclRdR!';
GRANT MAIN_READ_ACCESS TO CLIENT_READER;

DO $$
BEGIN
	IF EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname = 'client_updater') THEN
		DROP OWNED BY CLIENT_UPDATER;
		DROP ROLE CLIENT_UPDATER;
	END IF;
END; $$;
CREATE ROLE CLIENT_UPDATER 
	LOGIN
	PASSWORD 'upDRclint!';
GRANT MAIN_EDIT_ACCESS TO CLIENT_UPDATER;